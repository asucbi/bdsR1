---
title: "Bechdel + Programming"
author:
- Nicholas Duran & Jessica Kosie^[Authored modifications to original code]
- "Mine Ã‡etinkaya-Rundel^[Original author of exercise]"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    theme: yeti
    highlight: pygments
editor_options: 
  chunk_output_type: console
---

In this mini analysis we work with the data used in the FiveThirtyEight story titled ["The Dollar-And-Cents Case Against Hollywood's Exclusion of Women"](https://fivethirtyeight.com/features/the-dollar-and-cents-case-against-hollywoods-exclusion-of-women/).

```{r check-dataset}

?bechdel

```

We will be working with the results of a Bechdel test (this is a way of evaluating whether a work of fiction portrays women in a way that is sexist or characterized by gender stereotyping). 

To pass the Bechdel test, the film must pass three criteria:

  * the movie must have at least two women in it
  * the women must talk to each other
  * the women must talk to each other about something other than a man

Your task is to fill in the blanks denoted by `___`.

## Data and packages

We start with loading the packages we'll use.

*I like to click the gear above and choose "Chunk Output in Console" so that the output is displayed below rather than in this doc.*

```{r load-packages, message=FALSE}

___(fivethirtyeight)
___(tidyverse)

```

Now, let's check out our data. After reading in the data, you should *always* take a look to make sure it is the correct data / loaded correctly / etc!

Note: Often, we would read in a dataset. For today's code-along, the dataset is already built in to the `fivethirtyeight` package. The dataset is called `bechdel`.

```{r view-dataset, message=FALSE}

#use the `View()` function to look at the entire dataset. 
___(___)

#use the `head()` function to look at the first rows of the dataset.
___(___)
```

The dataset contains information on `r nrow(bechdel)` movies released between `r min(bechdel$year)` and `r max(bechdel$year)`.

However we'll focus our analysis on movies released between 1990 and 2013.

*TODO: we want to get a specific, narrower range of movies, which means we need to ignore some rows of our dataframe*

```{r filter-release, message=FALSE}

bechdel90_13 <- bechdel %>% ## note the "<-" assignment operator
  filter(___)

```

There are `r nrow(bechdel90_13)` such movies.

The financial variables we'll focus on are the following:

-   `budget_2013`: Budget in 2013 inflation adjusted dollars
-   `domgross_2013`: Domestic gross (US) in 2013 inflation adjusted dollars
-   `intgross_2013`: Total International (i.e., worldwide) gross in 2013 inflation adjusted dollars

And we'll also use the `binary` and `clean_test` variables for **grouping**.

## Analysis

Let's take a look at how median budget and gross vary by whether the movie passed the Bechdel test, which is stored in the `binary` variable.

*TODO: we want to get some stats on the various financial variables by whether they passed or failed the Bechdel test, i.e., groups*

```{r calc-median, message=FALSE}

bechdel90_13 %>%
  group_by(___) %>%
  summarise(med_budget = ___(___, na.rm = TRUE),
            med_domgross = ___(___, na.rm = TRUE),
            med_intgross = ___(___, na.rm = TRUE))

```

Next, let's take a look at how median budget and gross vary by a more detailed indicator of the Bechdel test result.

This information is stored in the `clean_test` variable, which takes on the following values:

-   `ok` = passes test
-   `dubious` = skeptical about whether it passes the test
-   `men` = women only talk about men
-   `notalk` = women don't talk to each other
-   `nowomen` = fewer than two women

*TODO: repeat what we did above, but grouping the stats by more refined categories*

```{r filter-clean_test, message=FALSE}

bechdel90_13 %>%
  ___(___) %>%
  summarize(med_budget = median(budget_2013), 
             med_domgross = median(domgross_2013, na.rm = TRUE),
             med_intgross = median(intgross_2013, na.rm = TRUE)                )

```

In order to evaluate how return on investment varies among movies that pass and fail the Bechdel test, we'll first create a new variable called `roi` as the ratio of the gross to budget.

*TODO: create a new variable based on criteria we need to specify*

```{r create-roi, message=FALSE}

bechdel90_13 <- bechdel90_13 %>% ## note the "<-" assignment operator
  mutate(roi = ___)

```

Let's see which movies have the highest return on investment.

*TODO: sort the data by roi (highest to lowest)*

```{r sort-roi, message=FALSE}

bechdel90_13 %>%
  ___(___) %>% 
  ___(title, roi, year, clean_test) # do we want all the columns? let's return the columns that are most important here

```

Below is a visualization of the return on investment by test result, however it's difficult to see the distributions due to a few extreme observations.

```{r example-plot, message=FALSE}

ggplot(data = bechdel90_13, 
       mapping = aes(x = clean_test, y = roi, color = binary)) +
  geom_boxplot() +
  labs(title = "Return on investment vs. Bechdel test result",
       x = "Detailed Bechdel result",
       y = "Return on investement by test result",
       color = "Binary Bechdel result")

```

What are those movies with *very* high returns on investment?

```{r high-roi, message=FALSE}

bechdel90_13 %>%
  filter(roi ___) %>%
  select(title, budget_2013, domgross_2013, year)

```

Zooming in on the movies with `roi < ___` provides a better view of how the medians across the categories compare:

*TODO: figure out how to do this zooming in; also don't forget to add a subtitle indicating that it was done*

```{r edit-plot, message=FALSE}

bechdel90_13_zoom400 <- bechdel90_13 %>%
  filter(roi ___) 

#copy and edit plot code from above. make sure to add a subtitle (hint: add subtitle = "[meaningful subtitle]" to the `labs` argument)

```
